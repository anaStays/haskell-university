--Вариант 3
--21, 26, 52, 53, 59, 2.2

--21. Даны два списка действительных чисел из n элементов. В
--одном списке количество гектаров, засеянных пшеницей, для
--i-го района, а во втором средняя урожайность в тоннах.
--Определить среднюю урожайность пшеницы по всей
--территории в целом и общее количество собранной пшеницы.
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Move guards forward" #-}


find :: [Double] -> [Double] -> (Double, Double)
find [] [] = (0,0)
find a b = (sf / sum a, sf)
    where
        sf = sum $ zipWith (*) a b
    
a :: [Double]
a = [1.0,2.1,3.3, 5.0]
b :: [Double]
b = [2.0,4.0,6.0, 7.2]


--26. Задано натуральное число k, найти все натуральные
--решения (x, y) уравнения 𝑥^2 + 𝑦^2 = 𝑘^2. Результат вернуть в
--виде списка кортежей. Решения (2, 3) и (3, 2) можно считать
--равными или различными, как будет удобнее.

ns:: Integer->[(Integer,Integer)]
ns k = [ (a,b) | a <- x, b <- y, a*a + b*b == kk ]
    where
        kk = k*k
        x = [1..k]
        y = [1..k]

test = ns 10


--52. Найти все целые числа из промежутка от a до b, у
--которых количество делителей равно k.

cd :: Int->Int
cd a = length [x | x <- [1..a], mod a x == 0]

fcd :: Int -> Int -> Int -> [Int]
fcd a b k = [ x | x <- [a..b], cd x == k ]

test52 = fcd 1 10 3


--53. Натуральное число называется «совершенным», если оно
--равно сумме своих делителей, включая 1 и исключая это
--самое число. Например, совершенным является число 6 (6 =
--1+2+3). Найти все совершенные числа, меньшие числа n.

d :: Int -> [Int]
d a = [x | x <- [1..a], mod a x == 0]

pn :: Int -> [Int]
pn n = [x | x <- [1..n], sum (d x) - x == x]

test53 = pn 10

--59. Гипотеза Гольдбаха гласит, что каждое положительное
--четное число больше 2 является суммой двух простых чисел.
--Пример: 28 = 5 + 23. Необходимо написать функцию для
--нахождения пар простых чисел, сумма которых дает заданное
--четное целое число, для списка чисел между двумя целыми
--числами: function 9 20 -> [(3,7),(5,7),(3,11),(3,13),(5,13),(3,17)]

--function :: Int -> Int -> [(Int, Int)]
--function a b = [(x, y) | x <- [1..a], y <- [1..b], cd x == 2, cd y == 2, x + y == b]

--test59 = function 9 20

function1 :: Int -> Int -> [(Int, Int)]
function1 a b = [(x, y) | x <- [1..a], y <- [1..b], cd x == 2, cd y == 2, even (x + y), a <= (x+y), (x+y) <= b ]

test591 = function1 9 20



--2.2 Написать функцию находящую сумму ряда с заданной точностью
--ℇ. Вычисление заканчивается, если модуль очередного слагаемого
--становится меньше заданного значения точности ℇ. Проверять
--корректность можно по контрольной формуле.
--x(2+x)/2! - x^3(4+x)/4! ... x^2i-1(2i+x)/(2i)!
fact:: Int -> Int
fact n = helper n 1
    where
        helper 1 s = s
        helper n s = helper (n-1) (s*n)

tn :: Double -> Int -> Double
tn x n = (-1)^(n - 1) * (x^(2 * n - 1) * (2 * fromIntegral n + x) / fromIntegral (fact (2*n)))

ss :: Double -> Double -> Double
ss x eps = helper 1 0.0
    where
        helper n s
            |abs (tn x n) < eps = s
            |otherwise = helper (n+1) (tn x n +s)

test2_2 = ss 3 0.0001